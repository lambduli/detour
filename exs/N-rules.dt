module â„•


axiom foo : âˆ€ o : Foo(o)

axiom id : âˆ€ i : Id(i, i)


syntax Empty

syntax â„•  = Zero    --  Zero : â„•
          | Suc(â„•)  --  Suc  : â„• -> â„•



syntax ð”¹  = ð•‹ | ð”½




judgment bool = ð”¹Test(ð”¹)

rule true-test :  |
                  |----------- true-test
                  | ð”¹Test(ð•‹)

rule false-test : |
                  |----------- false-test
                  | ð”¹Test(ð”½)



judgment nat-test = NT(â„•)

rule schema s-test for all objects (n : â„•) :
|
|---------------------------------------- s-test
| NT(n)




judgment sum = Sum(â„•, â„•, â„•)

rule schema sum-zero for all objects (n : â„•) :
|
|-------------------------------------- sum-zero
| Sum(Zero, n, n)


rule schema sum-suc for all objects (m : â„•), (n : â„•), (o : â„•) :
| Sum(m, n, o)
|-------------------------------------- sum-suc
| Sum(Suc(m), n, Suc(o))



theorem custom-rules : âˆ€ (n : â„•) : Sum( Zero , n , n )
uni : | for any (n : â„•)
      |-----------------------------------------------
      |
      | Sum( Zero, n , n )  by rule sum-zero

âˆ€ (n : â„•) : Sum( Zero , n , n )  by rule âˆ€-intro on uni


theorem custom-rules-1 : âˆƒ (n : â„•) : Sum( Zero , Suc(Zero) , n )
a : Sum( Zero, Suc(Zero) , m )  by rule sum-zero
âˆƒ (n : â„•) : Sum( Zero , Suc(Zero) , n )  by rule âˆƒ-intro on a


--  this should be rejected
--  but clearly, wasn't
--  TODO: FIX THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--  BUT IS IT REALLY WRONG? It seems that my intuition has failed me at first.
--  If `n` has unknown type that means that the âˆ€-elim or a custom rule
--  does not require it to have any specific type.
--  So we can just say "it was always â„•".
--  So it seems ok that if passed.
theorem rejected-1 : âˆƒ (n : â„•) : Foo(n)
a : Foo(n)  by rule âˆ€-elim on foo
r : âˆƒ (n : â„•) : Foo(n)  by rule âˆƒ-intro on a
--  so now it should mean that n has type â„•
--  so I can't make it anything else
--  so I can't do this 
-- _ : âˆƒ (i : ð•) : Foo(i)  by rule âˆƒ-intro on a --  it indeed, causes it to fail
âˆƒ (n : â„•) : Foo(n)  by rule repetition on r


--  this should work just fine
theorem just-fine : âˆƒ (n : â„•) : Id(n, n)
b : Id(m, m)  by rule âˆ€-elim on id
âˆƒ (n : â„•) : Id(n, n)  by rule âˆƒ-intro on b


--  this fails, but it kinda seems like it should be ok
--  TODO: figure it out
--  I think it could work. The tool would, however, have to do more work.
--  This is something like subsumption checking, I think.
--  And I have decided against it. Because it makes things more complicated for me.
--  Maybe in some future version.
-- theorem custom-rules-2 : âˆƒ n : Sum( Zero , Suc(Zero) , Suc(Zero) )
-- a : Sum( Zero, k, l )  by rule sum-zero
-- âˆƒ n : Sum( Zero , n , n )  by rule âˆƒ-intro on a


theorem custom-rules-3 : Sum( Zero , Suc(Zero) , Suc(Zero) )
Sum( Zero, Suc(Zero) , n )  by rule sum-zero


-- theorem totality : âˆ€ â„•â‚ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( â„•â‚ , â„•â‚‚ , â„•â‚ƒ )
-- |
-- |--------------------------------------------------------------------------------------------------
-- |
-- | --  Let's prove the base case: { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( Zero , â„•â‚‚ , â„•â‚ƒ ) }
-- |
-- | uni-n2 :  | for all (â„•2 : â„•)
-- |           |--------------------------------------------------------------------------------------
-- |           |
-- |           | sz : Sum( Zero , n2 , n3 )  by rule sum-zero
-- |           | âˆƒ â„•â‚ƒ : Sum( Zero , n2 , â„•â‚ƒ )  by rule âˆƒ-intro on sz
-- |
-- | base : { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( Zero , â„•â‚‚ , â„•â‚ƒ ) }  by rule âˆ€-intro on uni-n2
-- |
-- |
-- |
-- | --  Let's prove the inductive case: [ âˆ€ â„• : { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( â„• , â„•â‚‚ , â„•â‚ƒ ) } ==> { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( Suc(â„•) , â„•â‚‚ , â„•â‚ƒ ) } ]
-- |
-- | uni-n : | for all (nâ‚ : â„•)
-- |         |----------------------------------------------------------------------------------------
-- |         |
-- |         | impl :  | p3 : âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( â„• , â„•â‚‚ , â„•â‚ƒ )
-- |         |         |---------------------------------------------------------------------------------------------------------------------------------------
-- |         |         |
-- |         |         | uni-n2b : | for all (â„•2 : â„•)
-- |         |         |           |---------------------------------------------------------------------------------------------------------------------------
-- |         |         |           |  
-- |         |         |           | d1 : âˆƒ â„•â‚ƒ : Sum( nâ‚ , â„•2 , â„•â‚ƒ )  by rule âˆ€-elim on p3
-- |         |         |           |
-- |         |         |           | exn3 :  | p5 : Sum( nâ‚ , â„•2 , â„•3 ) for some (â„•3 : â„•)
-- |         |         |           |         |---------------------------------------------------------------------------------------------------------
-- |         |         |           |         |
-- |         |         |           |         | sum-n1+1 : Sum( Suc(nâ‚) , â„•2 , Suc(â„•3) )  by rule sum-suc on â„•, â„•2, â„•3
-- |         |         |           |         | âˆƒ â„•â‚ƒ : Sum( Suc(â„•) , â„•2 , â„•â‚ƒ )  by rule âˆƒ-intro on sum-n1+1
-- |         |         |           |
-- |         |         |           | âˆƒ â„•â‚ƒ : Sum( Suc(â„•) , â„•2 , â„•â‚ƒ )  by rule âˆƒ-elim on d1, exn3
-- |         |         |
-- |         |         | âˆ€ â„•â‚‚ : âˆƒ nâ‚ƒ : â„•(nâ‚ƒ) âˆ§ Sum( Suc(â„•) , â„•â‚‚ , nâ‚ƒ )  by rule âˆ€-intro on uni-n2b
-- |         |
-- |         | { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( â„• , â„•â‚‚ , â„•â‚ƒ ) } ==> { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( Suc(â„•) , â„•â‚‚ , â„•â‚ƒ ) }  by rule ==>-intro on impl
-- |
-- | step : [ âˆ€ â„• : { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( â„• , â„•â‚‚ , â„•â‚ƒ ) } ==> { âˆ€ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( Suc(â„•) , â„•â‚‚ , â„•â‚ƒ ) } ]  by rule âˆ€-intro on uni-n
-- |
-- |
-- | -- Let's use the induction now.
-- | âˆ€ â„•â‚ â„•â‚‚ : âˆƒ â„•â‚ƒ : Sum( â„•â‚ , â„•â‚‚ , â„•â‚ƒ )  by induction on base, step




-- judgment schema conj for all propositions A, B = AND(A, B)
--
-- rule schema and-intro for all propositions A, B : | A
--                                                  | B
--                                                  |------------------- and-intro
--                                                  | AND(A, B)


-- judgment Even(Î) :
-- rule even-z :
-- 
-- |
-- |-------------- even-z
-- | Even(Zero)
-- 
-- rule schema even-s for any object (n : â„•) :
-- 
-- | Even(n)
-- |-------------------- even-s
-- | Even(Suc(Suc(n)))
-- 
-- 
-- theorem even? : Even(n1), Even(n2) âŠ¢ n1 + n2 = n3 âˆ§ Even(n3)
-- suc (suc n1') + n2 = suc n3'  where n3 = suc n3'
-- 
-- -> scitani
-- suc n1' + n2 = suc n3''  where n3' = suc n3''
-- 
-- -> scitani
-- n1' + n2 = n3''
-- 
-- --> induction : Even(n3'')
-- 
-- -> even-s na n3''
-- 
-- -- hotovo


theorem what-even : âŠ¤
1 : | for any (n : â„•)
    |------------------
    |
    | NT(n)  by rule s-test

âŠ¤  by rule âŠ¤-intro




theorem example-of-case-analysis-on-â„• : âˆ€ (n : â„•) : âŠ¤
1 : | for any (n : â„•)
    |------------------------------------------------
    |
    | âŠ¤  by case analysis on n :
    |
    |       case Zero ->  |
    |                     |------------------------
    |                     |
    |                     | âŠ¤  by rule âŠ¤-intro
    |
    |       case Suc(m) ->  |
    |                       |----------------------
    |                       |
    |                       | âŠ¤  by rule âŠ¤-intro

âˆ€ (n : â„•) : âŠ¤  by rule âˆ€-intro on 1


theorem example-case-bool : âˆ€ (b : ð”¹) : ð”¹Test(b)
1 : | for any (b : ð”¹)
    |--------------------------------------------
    |
    | ð”¹Test(b)  by case analysis on b :
    |
    |               case ð•‹ -> |
    |                         |----------------------------
    |                         | ð”¹Test(b)  by rule true-test
    |
    |               case ð”½ -> |
    |                         |----------------------------
    |                         | ð”¹Test(b)  by rule false-test

âˆ€ (b : ð”¹) : ð”¹Test(b)  by rule âˆ€-intro on 1




--  proving anything from a contradiction
theorem prove-weird : âˆ€ (x : Empty) : Sum(Zero, Zero, Suc(Zero))
1 : | for any (p1 : Empty)
    |---------------------------------------------------------------
    |
    | Sum(Zero, Zero, Suc(Zero))  by case analysis on p1 :

âˆ€ (x : Empty) : Sum(Zero, Zero, Suc(Zero))  by rule âˆ€-intro on 1



-- --  this should eventually generalize to the following:
-- theorem schema prove-anything for any proposition A : Empty âŠ¢ A
-- | p1 : Empty
-- |--------------------------------------------------------------------
-- |
-- | A  by case analysis on on p1



-- theorem prove-false : âˆ€ (n : â„•) : âˆƒ (m : â„•) : Sum( Suc(Zero) , m , n ) âŠ¢ âŠ¥
-- --  there's a counter-example: n = Zero -> Sum( Suc(Zero) , ? , Zero )
-- --  There's no number so that this holds.
-- | 1 : âˆ€ (n : â„•) : âˆƒ (m : â„•) : Sum( Suc(Zero) , m , n )
-- |--------------------------------------------------------------------
-- |
-- | 2 : âˆƒ (m : â„•) : Sum( Suc(Zero) , m , Zero )  by rule âˆ€-intro on 1
-- |
-- | 3 : | 4 : Sum( Suc(Zero) , m1 , Zero )  for some (m1 : â„•)
-- |     |--------------------------------------------------------------
-- |     |
-- |     | âŠ¥  by case analysis on 4
-- |
-- | âŠ¥  by rule âˆƒ-elim on 2, 3


--  Can I do case analysis on an existential variable?
--  We don't know what it is. If we do case analysis and prove a thing
--  I guess it's ok. No matter what it actually is, we prove the same thing.