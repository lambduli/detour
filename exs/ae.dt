module AE


terminals : +, zero


syntax â„•, n = zero
            | suc â„•


--  Now, I want to define the + function
function Â·Î»+Â· :

  postulate âˆ€ (nâ‚ : â„•) (nâ‚‚ : â„•) : â„•(nâ‚ Î»+ nâ‚‚)
  --  This is one way to write it.
  --  On the other hand, the following notation is says exactly the same
  Î»+ : âˆ€ (nâ‚ : â„•) -> (nâ‚‚ : â„•) -> â„•
  --  Which one will should I pick?

  --  I also give the corresponding function

  Î»+ = Î» (nâ‚ : â„•) (nâ‚‚ : â„•) -> match nâ‚ with
                                zero -> nâ‚‚
                                suc nâ‚ƒ -> suc (nâ‚ƒ + nâ‚‚)


syntax ğ”¸ğ”¼, AE, ae = ( â„• + â„• )
                  | â„•


--  Here, I have `+` in two different roles.
--  As an uninterpreted function/constructor and as an interpreted function.
--  This either means I would have to name them differently or be very careful when they are used.

--  I think it might be possible to have them share the name.
--  I think, I only intend to use the Î»+ when I define operational semantics.
--  This means, that Î»+ never appears in a formula, rule or a theorem.

--  On the other hand, when it appears in the operational semantics section,
--  how do I know whether it is to compute the sum of two naturals or whether it is to construct
--  an ğ”¸ğ”¼ term?

--  I could know from types, but that is not ideal, I think.
--  So maybe they should not share the name after all.




--  Now what?
--  Now I can define operational semantics, judgments, and prove some theorems.


judgment nat-sum : â„• + â„• = â„•

rule schema sum-z for any object (n : â„•) :  |
                                            |--------------- sum-z
                                            | zero + n = n


rule schema sum-s for all object (nâ‚ : â„•), (nâ‚‚ : â„•), (nâ‚ƒ : â„•) : | nâ‚ + nâ‚‚ = nâ‚ƒ
                                                                |--------------------------- sum-s
                                                                | (suc nâ‚) + nâ‚‚ = (suc nâ‚ƒ)



judgment eq-nat: n = n

rule schema for any object (n : â„•) :  |
                                      |-------- eq-z
                                      | n = n




judgment a-reduction: ğ”¸ğ”¼  aáµ£  ğ”¸ğ”¼

rule schema a-plus for all object (nâ‚ : â„•), (nâ‚‚ : â„•), (nâ‚ƒ : â„•) :  | nâ‚ + nâ‚‚ = nâ‚ƒ
                                                                  |----------------------- a-plus
                                                                  | ( nâ‚ + nâ‚‚ )  aáµ£  nâ‚ƒ




judgment a-step: ğ”¸ğ”¼ -->a ğ”¸ğ”¼

rule schema step-base for all object (AE : ğ”¸ğ”¼), (AE' : â„•) : | AE  aáµ£  AE'
                                                            |------------- step-base
                                                            | AE -->a AE'


rule schema step-left-+ for all object (AE1 : ğ”¸ğ”¼), (AE1' : â„•) (AE2 : ğ”¸ğ”¼) :
| AE1 -->a AE1'
|------------------------------------ step-left-+
| ( AE1 + AE2 ) -->a ( AE1' + AE2 )


rule schema step-rightt-+ for all object (AE1 : ğ”¸ğ”¼), (AE2 : â„•) (AE2' : ğ”¸ğ”¼) :
| AE2 -->a AE2'
|------------------------------------ step-right-+
| ( AE1 + AE2 ) -->a ( AE1 + AE2' )




judgment a-multistep: ğ”¸ğ”¼ -->>a ğ”¸ğ”¼

rule schema multi-base for all object (AE : ğ”¸ğ”¼), (AE' : ğ”¸ğ”¼) : | AE --> AE'
                                                              |-------------- multi-base
                                                              | AE -->>a AE'

rule schema multi-refl for any object (AE : ğ”¸ğ”¼) : |
                                                  |-------------- multi-refl
                                                  | AE -->>a AE


rule schema multi-trans for all objects (AE1 : ğ”¸ğ”¼), (AE2 : ğ”¸ğ”¼), (AE3 : ğ”¸ğ”¼) :  | AE1 -->>a AE2
                                                                              | AE2 -->>a AE3
                                                                              |---------------- multi-trans
                                                                              | AE1 -->>a AE3




judgment a-eq: ğ”¸ğ”¼ = ğ”¸ğ”¼

rule schema eq-base for all objects (AE : ğ”¸ğ”¼), (AE' : ğ”¸ğ”¼) : | AE --> AE'
                                                            |----------- eq-base
                                                            | AE = AE'

--  TODO: finish the rewrite!!!

rule schema eq-refl for any object (AE : ğ”¸ğ”¼) :  |
                                                |---------- eq-refl
                                                | AE = AE


rule schema eq-trans for all objects (AE1 : ğ”¸ğ”¼), (AE2 : ğ”¸ğ”¼), (AE3 : ğ”¸ğ”¼) : | AE1 = AE2
                                                                          | AE2 = AE3
                                                                          |------------- eq-trans
                                                                          | AE1 = AE3


rule schema eq-sym for all objects (AE1 : ğ”¸ğ”¼), (AE2 : ğ”¸ğ”¼) : | AE2 = AE1
                                                            |------------ eq-sym
                                                            | AE1 = AE2





--  All those judgments above should be "runnable".
--  The tool generates an interpreter and we can enter terms like the following into its prompt:
--  > (suc zero) + zero -->a ğ”¸ğ”¼
--  here, ğ”¸ğ”¼ is a variable that can participate in unification
--  the interpreter should run the inference on the rules for -->a and produce all the possible results:

--  > ğ”¸ğ”¼ = suc zero --  if we take the `step-base`

--  No other steps are possible.



--  Now, there would be a few theorems.

-- theorem test0: exists "(" + #Z #(S Z) ")"  a  #(S Z).
--   d1: Z + S Z = S Z by rule sum-z
--   proof by rule a-plus on d1
-- end theorem
-- 
-- theorem test1:  forall imp: #n  a  #n
--                 exists contradiction.
-- 
--   proof by contradiction on imp
-- 
-- end theorem
