module b


--  homomorphic types

syntax ‚Ñï  = zero
          | suc ‚Ñï


--  equivalent to

```agda
data ‚Ñï : Set where
  zero : ‚Ñï
  suc : ‚àÄ (n : ‚Ñï) -> ‚Ñï
```

-------------------------------------------------------------------------------

--  can we have polymorphic second-order types?

syntax maybe for any type œÑ = nothing
                          | just œÑ


--  I think this could do.
--  We can't have "GADT" values.
--  It's understood exactly as Haskell's simple data definitions.

--  equivalent to

```haskell
data Maybe t  = Nothing
              | Just t
```

--  and to

```agda
data maybe : Set -> Set where
  nothing : ‚àÄ (œÑ : Type) -> maybe œÑ
  just : ‚àÄ (œÑ : Type) (a : œÑ) -> maybe œÑ
```


--  Could we have something like GADT syntax?
--  What would be some use-case?
--  Well, something could turn up.

syntax literal for any type œÑ where
  lit-‚Ñï : ‚Ñï -> literal ‚Ñï
  lit-ùîπ : ùîπ -> literal ùîπ

--  I guess this works.
--  But once we get to the level where we have the syntax where we write types
--  we will have to deal with a lot of stuff.
--  Types of constructors like ‚àÄ (œÑ : type) (a : œÑ) -> a -> a -> foo œÑ
--  or this type as an argument to a constructor and so on.


--  What about types parametrized with parametric types?

syntax foo for any type (œÑ : ?) ...

--  Here, the ? can be something like:  type
--                                      type -> type
--                                      (type -> type) -> type
--                                      ‚Ñï -> type
--                                      ‚àÄ (œÑ : type) -> (œÑ -> œÑ) -> œÑ -> œÑ
--                                      ‚àÄ (n : ‚Ñï) -> (n -> type) -> type
--                                      ‚àÄ (œÑ : type) (o : œÑ) -> (œÑ -> type) -> type
--  These are "kinds" of types.

--  For our syntax-types, we only allow parameters that are types over values, types and over
--  anything we allow.
--  Isn't that all types?

-------------------------------------------------------------------------------

--  So what about judgments now?

--  Simple, first-order judgments.
--  Those are types parametrized with values.

judgment nat-sum = ‚Ñï + ‚Ñï = ‚Ñï

rule schema sum-z for any object (n : ‚Ñï) :  |--------------- sum-z
                                            | zero + n = n


rule schema sum-s for all objects (m : ‚Ñï) (n : ‚Ñï) (o : ‚Ñï) : | m + n = o
                                                            |-------------------- sum-s
                                                            | suc m + n + suc o


--  this is equivalent to

```agda
data _+_=_ : ‚Ñï -> ‚Ñï -> ‚Ñï -> Set where
  sum-z : ‚àÄ (n : ‚Ñï) -> zero + n = n
  sum-s : ‚àÄ (m : ‚Ñï) (n : ‚Ñï) (o : ‚Ñï) -> m + n = o -> suc m + n = suc o
```


--  So, what about judgments over values and types as well?

judgment has-type for any type œÑ
              and for any object (o : œÑ) =  o : œÑ

rule schema typed for any type œÑ
              and for any object (o : œÑ) :  |--------- typed
                                            | o : œÑ

--  I don't even know what this would be useful for.
--  But maybe there are better example.

--  Maybe the rules would look different but the judgment is still over a type
--  and over an object. Like this.

rule nat-lit-typed :  |---------------- nat-lit-typed
                      | lit-nat ‚Ñï : ‚Ñï


--  This makes sense. Still, the judgment needs to be parametrized like this.

--  This is equivalent to

```agda
data _:_ (œÑ : Set) (o : œÑ) : Set where
  typed : ‚àÄ (œÑ : Set) (o : œÑ) -> o : œÑ

  nat-lit-typed : ‚àÄ (n : ‚Ñï) -> (lit-nat n) : Œù
```


--  What about judgments over judgments?
--  I don't know in general, but I think I can have propositions over propositions.


judgment conjunction for all propositions A, B = A ‚àß B

rule schema and-intro for all propositions A, B : | A
                                                  | B
                                                  |-------- and-intro
                                                  | A ‚àß B

--  The important restriction is that those propositions are really : Proposition
--  and never something that ‚Äî when applied to a thing ‚Äî gives a Proposition.
